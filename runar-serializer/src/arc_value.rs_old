use std::any::{Any, TypeId};
use std::clone::Clone;
use std::cmp::{Eq, PartialEq};
use std::collections::HashMap;
use std::fmt::{self, Debug};
use std::marker::Copy;
use std::sync::Arc;

use anyhow::{anyhow, Result};
use serde::de::{self, MapAccess, SeqAccess, Visitor};
use serde::ser::SerializeStruct;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use serde_json::Value as JsonValue;

use super::erased_arc::ErasedArc;
use super::AsArcValue; // Added import for the trait
use base64::engine::general_purpose::STANDARD;
use base64::Engine as _;
use prost::Message;
use super::encryption::{encrypt_bytes, decrypt_bytes}; // Assuming these exist for encryption handling
use super::traits::{CustomFromBytes, LabelResolver, KeyStore};
use crate::vec_types;
use crate::map_types;

// Type alias for complex deserialization function signature
pub(crate) type DeserializationFn =
    Arc<dyn Fn(&[u8]) -> Result<Box<dyn Any + Send + Sync>> + Send + Sync>;
// Type alias for the inner part of the complex serialization function signature
pub(crate) type SerializationFnInner = Box<dyn Fn(&dyn Any) -> Result<Vec<u8>> + Send + Sync>;

// Type alias for the JSON serialization function
// Takes an ErasedArc and attempts to serialize it to serde_json::Value
pub(crate) type JsonSerializationFn =
    Arc<dyn Fn(&ErasedArc) -> Result<serde_json::Value, anyhow::Error> + Send + Sync>;

/// Wrapper struct for deserializer function that implements Debug
#[derive(Clone)]
pub struct DeserializerFnWrapper {
    // The actual deserializer function
    pub func: DeserializationFn,
}

impl std::fmt::Debug for DeserializerFnWrapper {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeserializerFn")
    }
}

impl DeserializerFnWrapper {
    pub fn new<F>(func: F) -> Self
    where
        F: Fn(&[u8]) -> Result<Box<dyn Any + Send + Sync>> + Send + Sync + 'static,
    {
        DeserializerFnWrapper {
            func: Arc::new(func),
        }
    }

    pub fn call(&self, bytes: &[u8]) -> Result<Box<dyn Any + Send + Sync>> {
        (self.func)(bytes)
    }
}

/// Container for lazy deserialization data using Arc and offsets
#[derive(Clone)]
pub struct LazyDataWithOffset {
    /// The original type name from the serialized data
    pub type_name: String,
    /// Reference to the original shared buffer
    pub original_buffer: Arc<[u8]>,
    /// Start offset of the relevant data within the buffer
    pub start_offset: usize,
    /// End offset of the relevant data within the buffer
    pub end_offset: usize,
    /// Optional keystore for decryption
    pub keystore: Option<Arc<KeyStore>>,
    // Removed deserializer and alias_deserializer
}

impl fmt::Debug for LazyDataWithOffset {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("LazyDataWithOffset")
            .field("type_name", &self.type_name)
            .field("original_buffer_len", &self.original_buffer.len())
            .field("data_segment_len", &(self.end_offset - self.start_offset))
            .field("start_offset", &self.start_offset)
            .field("end_offset", &self.end_offset)
            .finish()
    }
}

/// Categorizes the value for efficient dispatch
#[derive(Clone, Copy, Debug, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum ValueCategory {
    Primitive,
    List,
    Map,
    Struct,
    Null,
    /// Raw bytes (used for Vec<u8>, not for lazy deserialization)
    Bytes,
    Json,
}

/// The canonical value type for the system, using type-erased Arcs.
#[derive(Clone)]
pub struct ArcValue {
    /// The category of the contained value
    pub category: ValueCategory,
    /// The contained type-erased value
    /// Note: ErasedArc is type-erased and requires custom serde impl. Only registered types are supported.
    pub value: Option<ErasedArc>,
    serialize_fn: Option<Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync>>,
}

impl fmt::Debug for ArcValue {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ArcValue")
            .field("category", &self.category)
            .field("value", &self.value)
            .field("serialize_fn", &if self.serialize_fn.is_some() { "Some(<fn>)" } else { "None" })
            .finish()
    }
}

impl PartialEq for ArcValue {
    fn eq(&self, other: &Self) -> bool {
        if self.category != other.category {
            return false;
        }
        match (&self.value, &other.value) {
            (Some(v1), Some(v2)) => v1.eq_value(v2),
            (None, None) => true,
            _ => false,
        }
    }
}

impl Eq for ArcValue {}

impl AsArcValue for ArcValue {
    fn into_arc_value_type(self) -> ArcValue {
        self // It already is an ArcValue
    }
}

// Fix json_fn and ser_fn for bool
impl AsArcValue for bool {
    fn into_arc_value_type(self) -> ArcValue {
        let arc = Arc::new(self);
        let ser_fn: Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync> = Arc::new(move |erased, _, _| {
            let val = erased.as_arc::<bool>()?;
            Ok(vec![if *val { 1 } else { 0 }])
        });
        ArcValue { category: ValueCategory::Primitive, value: Some(ErasedArc::new(arc)), serialize_fn: Some(ser_fn) }
    }
}
// Similar fixes for String
impl AsArcValue for String {
    fn into_arc_value_type(self) -> ArcValue {
        let arc = Arc::new(self);
        let ser_fn: Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync> = Arc::new(move |erased, _, _| {
            let val = erased.as_arc::<String>()?;
            Ok(val.as_bytes().to_vec())
        });
        ArcValue { category: ValueCategory::Primitive, value: Some(ErasedArc::new(arc)), serialize_fn: Some(ser_fn) }
    }
}
// For &str similar
impl AsArcValue for &str {
    fn into_arc_value_type(self) -> ArcValue {
        let arc = Arc::new(self.to_string());
        let ser_fn: Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync> = Arc::new(move |erased, _, _| Ok(erased.as_arc::<String>()?.as_bytes().to_vec()));
        ArcValue { category: ValueCategory::Primitive, value: Some(ErasedArc::new(arc)), serialize_fn: Some(ser_fn) }
    }
}
// For i32
impl AsArcValue for i32 {
    fn into_arc_value_type(self) -> ArcValue {
        let arc = Arc::new(self);
        let ser_fn: Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync> = Arc::new(move |erased, _, _| {
            let val = erased.as_arc::<i32>()?;
            Ok(val.to_be_bytes().to_vec())
        });
        ArcValue { category: ValueCategory::Primitive, value: Some(ErasedArc::new(arc)), serialize_fn: Some(ser_fn) }
    }
}
// Similar for i64 and f64
impl AsArcValue for i64 {
    fn into_arc_value_type(self) -> ArcValue {
        let arc = Arc::new(self);
        let ser_fn: Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync> = Arc::new(move |erased, _, _| Ok(erased.as_arc::<i64>()?.to_be_bytes().to_vec()));
        ArcValue { category: ValueCategory::Primitive, value: Some(ErasedArc::new(arc)), serialize_fn: Some(ser_fn) }
    }
}

impl AsArcValue for () {
    fn into_arc_value_type(self) -> ArcValue {
        ArcValue::null() // Represent unit type as null payload
    }
}

impl AsArcValue for f64 {
    fn into_arc_value_type(self) -> ArcValue {
        let arc = Arc::new(self);
        let ser_fn: Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync> = Arc::new(move |erased, _, _| Ok(erased.as_arc::<f64>()?.to_be_bytes().to_vec()));
        ArcValue { category: ValueCategory::Primitive, value: Some(ErasedArc::new(arc)), serialize_fn: Some(ser_fn) }
    }
}

impl ArcValue {
    /// Creates an `ArcValue` from a `serde_json::Value`.
    ///
    /// This function recursively converts JSON values into their corresponding `ArcValue` representations.
    /// - JSON null becomes `ArcValue::null()`.
    /// - JSON booleans become `ArcValue::new_primitive(bool)`.
    /// - JSON numbers become `ArcValue::new_primitive(i64)` or `ArcValue::new_primitive(f64)` if possible,
    ///   otherwise `ArcValue::new_primitive(String)`.
    /// - JSON strings become `ArcValue::new_primitive(String)`.
    /// - JSON arrays become `ArcValue::new_list(Vec<ArcValue>)`.
    /// - JSON objects become `ArcValue::new_map(HashMap<String, ArcValue>)`.
    pub fn from_json(json_val: JsonValue) -> Self {
        match json_val {
            JsonValue::Null => ArcValue::null(),
            JsonValue::Bool(b) => b.into_arc_value_type(),
            JsonValue::Number(n) => {
                if let Some(i) = n.as_i64() {
                    i.into_arc_value_type()
                } else if let Some(f) = n.as_f64() {
                    f.into_arc_value_type()
                } else {
                    0i64.into_arc_value_type() // fallback
                }
            }
            JsonValue::String(s) => s.into_arc_value_type(),
            JsonValue::Array(arr) => {
                ArcValue::new_list(arr.into_iter().map(ArcValue::from_json).collect())
            }
            JsonValue::Object(obj) => {
                ArcValue::new_map(obj.into_iter().map(|(k, v)| (k, ArcValue::from_json(v))).collect())
            }
        }
    }

    /// Create a new ArcValue
    pub fn new(value: ErasedArc, category: ValueCategory) -> Self {
        Self {
            category,
            value: Some(value),
            serialize_fn: None,
        }
    }

    /// Create a new bytes value (Vec<u8>)
    pub fn new_bytes(bytes: Vec<u8>) -> Self {
        let arc_bytes = Arc::new(bytes);
        let ser_fn: Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync> = Arc::new(move |erased_arc, _, _| {
            let typed_arc = erased_arc.as_arc::<Vec<u8>>()?;
            Ok((*typed_arc).clone())
        });
        Self {
            category: ValueCategory::Bytes,
            value: Some(ErasedArc::new(arc_bytes)),
            serialize_fn: Some(ser_fn),
        }
    }

    /// Create a new list value
    pub fn new_list(values: Vec<ArcValue>) -> Self {
        let arc = Arc::new(values);
        let ser_fn: Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync> = Arc::new(move |erased, ks, res| {
            let list = erased.as_arc::<Vec<ArcValue>>()?;
            let mut proto_list = vec_types::VecArcValue::default();
            for item in list.iter() {
                proto_list.entries.push(item.serialize(ks, res)?);
            }
            Ok(proto_list.encode_to_vec())
        });
        Self {
            category: ValueCategory::List,
            value: Some(ErasedArc::new(arc)),
            serialize_fn: Some(ser_fn),
        }
    }

    /// Create a new list from existing vector
    pub fn from_list(values: Vec<ArcValue>) -> Self {
        Self::new_list(values)
    }

    /// Create a new map value
    pub fn new_map(map: HashMap<String, ArcValue>) -> Self {
        let arc = Arc::new(map);
        let ser_fn: Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync> = Arc::new(move |erased, ks, res| {
            let map = erased.as_arc::<HashMap<String, ArcValue>>()?;
            let mut proto_map = map_types::StringToArcValueMap::default();
            for (k, v) in map.iter() {
                proto_map.entries.insert(k.clone(), v.serialize(ks, res)?);
            }
            Ok(proto_map.encode_to_vec())
        });
        Self {
            category: ValueCategory::Map,
            value: Some(ErasedArc::new(arc)),
            serialize_fn: Some(ser_fn),
        }
    }

    /// Create a new map from existing map
    pub fn from_map(map: HashMap<String, ArcValue>) -> Self {
        Self::new_map(map)
    }

    /// Create a null value
    pub fn null() -> Self {
        Self {
            category: ValueCategory::Null,
            value: None,
            serialize_fn: None,
        }
    }

    /// Create a new JSON value
    pub fn new_json(value: serde_json::Value) -> Self {
        let arc = Arc::new(value.clone());
        let ser_fn: Arc<dyn Fn(&ErasedArc, Option<&Arc<KeyStore>>, Option<&dyn LabelResolver>) -> Result<Vec<u8>> + Send + Sync> = Arc::new(move |erased_arc, _, _| -> Result<Vec<u8>, anyhow::Error> {
            let typed_arc = erased_arc.as_arc::<JsonValue>()?;
            serde_json::to_vec(&*typed_arc).map_err(anyhow::Error::from)
        });
        Self {
            category: ValueCategory::Json,
            value: Some(ErasedArc::new(arc)),
            serialize_fn: Some(ser_fn),
        }
    }

    /// Check if this value is null
    pub fn is_null(&self) -> bool {
        self.value.is_none() && self.category == ValueCategory::Null
    }

    /// Get list as a reference of the specified element type
    pub fn as_list_ref<T>(&mut self) -> Result<Arc<Vec<T>>>
    where
        T: 'static + Clone + CustomFromBytes + Debug + Send + Sync,
    {
        // Integrate intrinsic logic, remove registry parts
        if self.category != ValueCategory::List {
            return Err(anyhow!("Value is not a list (category: {:?})", self.category));
        }
        match &mut self.value {
            Some(ref mut actual_value) => {
                if actual_value.is_lazy {
                    // Extract lazy data
                    let lazy_data = actual_value.get_lazy_data()?;
                    let bytes = &lazy_data.original_buffer[lazy_data.start_offset..lazy_data.end_offset];
                    let is_encrypted = lazy_data.type_name.starts_with("Encrypted");
                    let bytes = if is_encrypted { decrypt_bytes(bytes, lazy_data.keystore.as_ref().ok_or(anyhow!("no keystore"))?)? } else { bytes.to_vec() };
                    let proto = vec_types::VecArcValue::decode(bytes.as_slice())?;
                    let mut vec = Vec::new();
                    for entry in proto.entries {
                        let mut av = Self::deserialize(&entry, lazy_data.keystore.as_ref())?;
                        let item = av.as_type::<T>()?;
                        vec.push(item);
                    }
                    *actual_value = ErasedArc::new(Arc::new(vec));
                }
                actual_value.as_arc::<Vec<T>>()
            }
            None => Err(anyhow!("Null value")),
        }
    }

    /// Get map as a reference of the specified key/value types.
    /// If the value is lazy, it will be deserialized and made eager in-place.
    pub fn as_map_ref<K, V>(&mut self) -> Result<Arc<HashMap<K, V>>>
    where
        K: 'static
            + Clone
            + Serialize
            + for<'de> Deserialize<'de>
            + Eq
            + std::hash::Hash
            + fmt::Debug
            + Send
            + Sync,
        V: 'static + Clone + Serialize + for<'de> Deserialize<'de> + fmt::Debug + Send + Sync,
    {
        if self.category != ValueCategory::Map {
            // Special fallback: if the value is still in lazy JSON form, but the caller
            // expects a HashMap<String, ArcValue>, attempt on-the-fly conversion by
            // delegating to as_type_ref. This mirrors the logic that already exists in
            // `as_type_ref`, but exposes it for the `as_map_ref` convenience API which
            // callers (e.g. the single-parameter extraction logic in the `action` macro)
            // rely on.
            if self.category == ValueCategory::Json
                && std::any::TypeId::of::<K>() == std::any::TypeId::of::<String>()
                && std::any::TypeId::of::<V>() == std::any::TypeId::of::<ArcValue>()
            {
                // Attempt conversion; `as_type_ref` will update `self.category` → Map on success.
                let arc_map_sa = self.as_type_ref::<HashMap<String, ArcValue>>()?;
                // SAFETY: We just verified that K==String and V==ArcValue.
                let arc_map_typed = unsafe {
                    std::mem::transmute::<Arc<HashMap<String, ArcValue>>, Arc<HashMap<K, V>>>(
                        arc_map_sa,
                    )
                };
                return Ok(arc_map_typed);
            }

            return Err(anyhow!(
                "Category mismatch: Expected Map, found {:?}",
                self.category
            ));
        }

        match &mut self.value {
            Some(ref mut actual_value) => {
                if actual_value.is_lazy {
                    let type_name_clone: String;
                    let original_buffer_clone: Arc<[u8]>;
                    let start_offset_val: usize;
                    let end_offset_val: usize;

                    {
                        let lazy_data_arc = actual_value.get_lazy_data().map_err(|e| {
                            anyhow!(
                                "Failed to get lazy data from ErasedArc despite is_lazy flag: {}",
                                e
                            )
                        })?;
                        type_name_clone = lazy_data_arc.type_name.clone();
                        original_buffer_clone = lazy_data_arc.original_buffer.clone();
                        start_offset_val = lazy_data_arc.start_offset;
                        end_offset_val = lazy_data_arc.end_offset;
                    }

                    // Perform type name check before deserialization
                    let expected_type_name = std::any::type_name::<HashMap<K, V>>();
                    if !super::erased_arc::compare_type_names(expected_type_name, &type_name_clone)
                    {
                        self.value = Some(actual_value.clone()); // Put the original lazy value back
                        return Err(anyhow!(
                            "Lazy data type mismatch: expected compatible with {}, but stored type is {}",
                            expected_type_name,
                            type_name_clone
                        ));
                    }

                    let _data_slice = &original_buffer_clone[start_offset_val..end_offset_val];

                    // Get the lazy data again to access the deserializer
                    let lazy_data_arc = actual_value.get_lazy_data().map_err(|e| {
                        anyhow!("Failed to get lazy data despite is_lazy flag: {}", e)
                    })?;

                    // Use registry deserializer - this is the only path
                    let deserializer = lazy_data_arc.deserializer.as_ref().ok_or_else(|| {
                        anyhow!(
                            "No deserializer available for lazy map type {}",
                            type_name_clone
                        )
                    })?;

                    let boxed = deserializer
                        .call(_data_slice)
                        .map_err(|e| anyhow!("Registry deserializer error: {e}"))?;
                    let concrete = boxed.downcast::<HashMap<K, V>>()
                        .map_err(|_| anyhow!("Registry deserializer returned unexpected type (expected HashMap<{}, {}>)", std::any::type_name::<K>(), std::any::type_name::<V>()))?;
                    let deserialized_map: HashMap<K, V> = *concrete;

                    *actual_value = ErasedArc::new(Arc::new(deserialized_map));
                }
                // Explicitly assign and return
                actual_value.as_arc::<HashMap<K, V>>().map_err(|e| {
                    anyhow!("Failed to cast eager value to map: {}. Expected HashMap<{},{}>, got {}. Category: {:?}", 
                        e, std::any::type_name::<K>(), std::any::type_name::<V>(), actual_value.type_name(), self.category)
                }) // Return the result
            }
            None => Err(anyhow!(
                "Cannot get map reference from a null ArcValue (category: {:?})",
                self.category
            )),
        }
    }

    /// Get value as the specified type (makes a clone).
    pub fn as_type<T>(&mut self) -> Result<T>
    where
        T: 'static + Clone + CustomFromBytes + Debug + Send + Sync,
    {
        // Integrate bottom logic
        let arc_ref = self.as_type_ref::<T>()?;
        Ok((*arc_ref).clone())
    }

    /// Get struct as a reference of the specified type.
    /// If the value is lazy, it will be deserialized and made eager in-place.
    pub fn as_struct_ref<T>(&mut self) -> Result<Arc<T>>
    where
        T: 'static + Clone + CustomFromBytes + Debug + Send + Sync,
    {
        if self.category != ValueCategory::Struct {
            return Err(anyhow!(
                "Category mismatch: Expected Struct, found {:?}",
                self.category
            ));
        }

        match &mut self.value {
            Some(ref mut actual_value) => {
                if actual_value.is_lazy {
                    let lazy_data = actual_value.get_lazy_data()?;
                    let bytes = &lazy_data.original_buffer[lazy_data.start_offset..lazy_data.end_offset];
                    let expected_type_name = std::any::type_name::<T>();
                    let is_encrypted = lazy_data.type_name.starts_with("Encrypted") && lazy_data.type_name.strip_prefix("Encrypted").map_or(false, |s| s == expected_type_name);
                    let decoded = if is_encrypted {
                        T::from_encrypted_bytes(bytes, lazy_data.keystore.as_ref())
                    } else {
                        T::from_plain_bytes(bytes, lazy_data.keystore.as_ref())
                    }?;
                    *actual_value = ErasedArc::new(Arc::new(decoded));
                }
                actual_value.as_arc::<T>()
            }
            None => Err(anyhow!(
                "Cannot get struct reference from a null ArcValue (category: {:?})",
                self.category
            )),
        }
    }

    pub fn to_json_value(&mut self) -> Result<serde_json::Value> {
        match self.category {
            ValueCategory::Null => Ok(serde_json::Value::Null),
            ValueCategory::Primitive => {
                if let Ok(arc_str) = self.value.as_ref().unwrap().as_arc::<String>() {
                    Ok(serde_json::Value::String((*arc_str).clone()))
                } else if let Ok(arc_i64) = self.value.as_ref().unwrap().as_arc::<i64>() {
                    Ok(serde_json::Value::Number(serde_json::Number::from(*arc_i64)))
                } else if let Ok(arc_bool) = self.value.as_ref().unwrap().as_arc::<bool>() {
                    Ok(serde_json::Value::Bool(*arc_bool))
                } else if let Ok(arc_f64) = self.value.as_ref().unwrap().as_arc::<f64>() {
                    Ok(serde_json::Value::Number(serde_json::Number::from_f64(*arc_f64).ok_or(anyhow!("invalid f64"))?))
                } else if let Ok(arc_i32) = self.value.as_ref().unwrap().as_arc::<i32>() {
                    Ok(serde_json::Value::Number(serde_json::Number::from(*arc_i32)))
                } else {
                    Err(anyhow!("Unsupported primitive type for JSON serialization"))
                }
            }
            ValueCategory::Bytes => {
                let bytes = self.value.as_ref().unwrap().as_arc::<Vec<u8>>()?;
                Ok(serde_json::Value::String(STANDARD.encode(&*bytes)))
            }
            ValueCategory::Json => {
                let json = self.value.as_ref().unwrap().as_arc::<JsonValue>()?;
                Ok((*json).clone())
            }
            ValueCategory::List => {
                let list_arc = self.as_list_ref::<ArcValue>()?;
                let mut json_array = Vec::new();
                for item_avt in list_arc.iter() {
                    let mut cloned_item = item_avt.clone();
                    json_array.push(cloned_item.to_json_value()?);
                }
                Ok(serde_json::Value::Array(json_array))
            }
            ValueCategory::Map => {
                let map_arc = self.as_map_ref::<String, ArcValue>()?;
                let mut json_map = serde_json::Map::new();
                for (key, value_avt) in map_arc.iter() {
                    let mut cloned_value = value_avt.clone();
                    json_map.insert(key.clone(), cloned_value.to_json_value()?);
                }
                Ok(serde_json::Value::Object(json_map))
            }
            ValueCategory::Struct => Err(anyhow!("JSON serialization not supported for Struct")),
        }
    }

    /// Convenience accessor to retrieve the value category (copy).
    pub fn category(&self) -> ValueCategory {
        self.category
    }

    // Add deserialize method
    pub fn deserialize(bytes: &[u8], keystore: Option<&Arc<KeyStore>>) -> Result<ArcValue> {
        // Extract header (reuse extract_header_from_slice if possible, but since registry is going away, inline it)
        if bytes.is_empty() { return Err(anyhow!("Empty bytes")); }
        let category_byte = bytes[0];
        let category = match category_byte {
            0 => ValueCategory::Null,
            1 => ValueCategory::Primitive,
            2 => ValueCategory::List,
            3 => ValueCategory::Map,
            4 => ValueCategory::Struct,
            5 => ValueCategory::Bytes,
            6 => ValueCategory::Json,
            _ => return Err(anyhow!("Invalid category byte: {}", category_byte)),
        };
        if category == ValueCategory::Null { return Ok(ArcValue::null()); }
        let type_name_len = bytes[1] as usize;
        let type_name = String::from_utf8(bytes[2..2+type_name_len].to_vec())?;
        let data_start = 2 + type_name_len;
        let data_slice = &bytes[data_start..];

        // Create Lazy
        let lazy = LazyDataWithOffset {
            type_name,
            original_buffer: Arc::from(bytes.to_vec()),
            start_offset: data_start,
            end_offset: bytes.len(),
            keystore: keystore.cloned(),
        };
        let erased = ErasedArc::from_value(lazy);
        Ok(ArcValue::new(erased, category))
    }

    // Add intrinsic serialize
    pub fn serialize(&self, keystore: Option<&Arc<KeyStore>>, resolver: Option<&dyn LabelResolver>) -> Result<Vec<u8>> {
        let mut buf = Vec::new();
        if self.is_null() {
            buf.push(0); // Null category
            return Ok(buf);
        }
        let inner = self.value.as_ref().ok_or(anyhow!("No value"))?;
        let type_name = inner.type_name();
        let category_byte = match self.category {
            ValueCategory::Null => 0,
            ValueCategory::Primitive => 1,
            ValueCategory::List => 2,
            ValueCategory::Map => 3,
            ValueCategory::Struct => 4,
            ValueCategory::Bytes => 5,
            ValueCategory::Json => 6,
        };
        buf.push(category_byte);
        let type_name_bytes = type_name.as_bytes();
        if type_name_bytes.len() > 255 {
            return Err(anyhow!("Type name too long"));
        }
        buf.push(type_name_bytes.len() as u8);
        buf.extend_from_slice(type_name_bytes);

        let inner_bytes = if let Some(ser_fn) = &self.serialize_fn {
            ser_fn(inner, keystore, resolver)?
        } else {
            // fallback intrinsic serialization as in the code
            let mut buf = Vec::new();
            if let Ok(arc_str) = inner.as_arc::<String>() {
                buf.extend_from_slice(arc_str.as_bytes());
            } else if let Ok(arc_i64) = inner.as_arc::<i64>() {
                buf.extend_from_slice(&arc_i64.to_be_bytes());
            } else if let Ok(arc_bool) = inner.as_arc::<bool>() {
                buf.push(if *arc_bool { 1 } else { 0 });
            } else if let Ok(arc_f64) = inner.as_arc::<f64>() {
                buf.extend_from_slice(&arc_f64.to_be_bytes());
            } else if let Ok(arc_i32) = inner.as_arc::<i32>() {
                buf.extend_from_slice(&arc_i32.to_be_bytes());
            } else {
                return Err(anyhow!("Unsupported primitive type"));
            }
            Ok(buf)
        };

        if type_name.starts_with("Encrypted") {
            let ks = keystore.ok_or(anyhow!("Keystore required for encryption"))?;
            let encrypted = encrypt_bytes(&inner_bytes, ks)?;
            buf.extend(encrypted);
        } else {
            buf.extend(inner_bytes);
        }
        Ok(buf)
    }
}

// Update as_type<T>(&mut self) to handle intrinsic deserialization using stored keystore
// In as_type_ref, if is_lazy, extract data_slice, use type_name to dispatch intrinsic deserializer, use lazy.keystore for decryption if needed
// Similar for as_list_ref, as_map_ref, etc.

impl ArcValue {
    /// Get value as a reference of the specified type
    pub fn as_type_ref<T>(&mut self) -> Result<Arc<T>>
    where
        T: 'static + Clone + CustomFromBytes + Debug + Send + Sync,
    {
        if let Some(ref mut inner) = self.value {
            if inner.is_lazy {
                let lazy = inner.get_lazy_data()?;
                let bytes_to_decode = &lazy.original_buffer[lazy.start_offset..lazy.end_offset];
                let is_encrypted = lazy.type_name.starts_with("Encrypted");
                let bytes_to_decode = if is_encrypted { decrypt_bytes(bytes_to_decode, lazy.keystore.as_ref().ok_or(anyhow!("no keystore"))?)? } else { bytes_to_decode.to_vec() };
                let decoded: T = match self.category {
                    ValueCategory::Primitive => {
                        if TypeId::of::<T>() == TypeId::of::<String>() {
                            let s = String::from_utf8(bytes_to_decode)?;
                            unsafe { Ok(Arc::new(*( &s as *const String as *const T ))) }
                        } else if TypeId::of::<T>() == TypeId::of::<i64>() {
                            let mut buf = [0; 8];
                            buf.copy_from_slice(&bytes_to_decode[0..8]);
                            let i = i64::from_be_bytes(buf);
                            unsafe { Ok(Arc::new(*( &i as *const i64 as *const T ))) }
                        } else if TypeId::of::<T>() == TypeId::of::<bool>() {
                            (bytes_to_decode[0] != 0).into()
                        } else if TypeId::of::<T>() == TypeId::of::<f64>() {
                            let mut buf = [0; 8];
                            buf.copy_from_slice(&bytes_to_decode[0..8]);
                            let f = f64::from_be_bytes(buf);
                            unsafe { Ok(Arc::new(*( &f as *const f64 as *const T ))) }
                        } // Add more primitives
                        else { return Err(anyhow!("Unsupported primitive")); }
                    }
                    ValueCategory::List => {
                        if TypeId::of::<T>() == TypeId::of::<Vec<ArcValue>>() {
                            let proto = vec_types::VecArcValue::decode(bytes_to_decode.as_slice())?;
                            let mut vec = Vec::new();
                            for entry in proto.entries {
                                vec.push(Self::deserialize(&entry, lazy.keystore.as_ref())?);
                            }
                            let arc_vec = Arc::new(vec);
                            unsafe { Ok(std::mem::transmute::<Arc<Vec<ArcValue>>, Arc<T>>(arc_vec)) }
                        } else { Err(anyhow!("Type mismatch")) }
                    }
                    ValueCategory::Map => {
                        if TypeId::of::<T>() == TypeId::of::<HashMap<String, ArcValue>>() {
                            let proto = map_types::StringToArcValueMap::decode(bytes_to_decode.as_slice())?;
                            let mut map = HashMap::new();
                            for (k, entry) in proto.entries {
                                map.insert(k, Self::deserialize(&entry, lazy.keystore.as_ref())?);
                            }
                            let arc_map = Arc::new(map);
                            unsafe { Ok(std::mem::transmute::<Arc<HashMap<String, ArcValue>>, Arc<T>>(arc_map)) }
                        } else { Err(anyhow!("Type mismatch")) }
                    }
                    ValueCategory::Struct => {
                        // Assume macro adds from_bytes to T
                        T::from_plain_bytes(&bytes_to_decode, lazy.keystore.as_ref())?
                    }
                    _ => return Err(anyhow!("Unsupported category")),
                };

                *inner = ErasedArc::new(Arc::new(decoded));
            }
            inner.as_arc::<T>()
        } else {
            Err(anyhow!("No value"))
        }
    }

    pub fn as_type<T>(&mut self) -> Result<T>
    where T: 'static + Clone + CustomFromBytes + Debug + Send + Sync,
    {
        if self.value.is_some() { return self.value.as_ref().ok_or(anyhow!("No value"))?.as_arc::<T>().map(|arc| (*arc).clone()); }
        let lazy = self.value.as_ref().ok_or(anyhow!("No value"))?.get_lazy_data()?;
        let bytes_to_decode = &lazy.original_buffer[lazy.start_offset..lazy.end_offset];
        let is_encrypted = lazy.type_name.starts_with("Encrypted");
        let bytes_to_decode = if is_encrypted { decrypt_bytes(bytes_to_decode, lazy.keystore.as_ref().ok_or(anyhow!("no keystore"))?)? } else { bytes_to_decode.to_vec() };
        let decoded = match self.category {
            ValueCategory::Primitive => {
                if TypeId::of::<T>() == TypeId::of::<String>() {
                    let s = String::from_utf8(bytes_to_decode)?;
                    unsafe { Ok(*( &s as *const String as *const T )) }
                } else if TypeId::of::<T>() == TypeId::of::<i64>() {
                    let buf = bytes_to_decode.try_into()?;
                    let i = i64::from_be_bytes(buf);
                    i as T
                } else if TypeId::of::<T>() == TypeId::of::<bool>() {
                    let b = bytes_to_decode[0] != 0;
                    unsafe { Ok(*( &b as *const bool as *const T )) }
                } else if TypeId::of::<T>() == TypeId::of::<f64>() {
                    let buf = bytes_to_decode.try_into()?;
                    let f = f64::from_be_bytes(buf);
                    f as T
                } else if TypeId::of::<T>() == TypeId::of::<i32>() {
                    let buf = bytes_to_decode.try_into()?;
                    let i = i32::from_be_bytes(buf);
                    i as T
                } else { Err(anyhow!("Unsupported primitive type")) }
            }
            ValueCategory::List => {
                if TypeId::of::<T>() == TypeId::of::<Vec<ArcValue>>() {
                    let v = self.as_list_ref()?.as_ref().clone();
                    unsafe { Ok(*( &v as *const Vec<ArcValue> as *const T )) }
                } else { Err(anyhow!("Type mismatch for list")) }
            }
            ValueCategory::Map => {
                if TypeId::of::<T>() == TypeId::of::<HashMap<String, ArcValue>>() {
                    let m = self.as_map_ref()?.as_ref().clone();
                    Ok(m)
                } else { Err(anyhow!("Type mismatch for map")) }
            }
            ValueCategory::Struct => T::from_plain_bytes(&bytes_to_decode, lazy.keystore.as_ref())?,
            ValueCategory::Json => serde_json::from_value::<T>((*self.value.as_ref().ok_or(anyhow!("No value"))?.as_arc::<JsonValue>()?).clone()).map_err(anyhow::Error::from)?,
            _ => Err(anyhow!("Unsupported category")),
        };
        self.value = Some(ErasedArc::new(Arc::new(decoded.clone())));
        Ok(decoded)
    }

    pub fn as_list_ref<T>(&mut self) -> Result<Arc<Vec<T>>>
    where
        T: 'static + Clone + CustomFromBytes + Debug + Send + Sync,
    {
        // Integrate intrinsic logic, remove registry parts
        if self.category != ValueCategory::List {
            return Err(anyhow!("Value is not a list (category: {:?})", self.category));
        }
        match &mut self.value {
            Some(ref mut actual_value) => {
                if actual_value.is_lazy {
                    // Extract lazy data
                    let lazy_data = actual_value.get_lazy_data()?;
                    let bytes = &lazy_data.original_buffer[lazy_data.start_offset..lazy_data.end_offset];
                    let is_encrypted = lazy_data.type_name.starts_with("Encrypted");
                    let bytes = if is_encrypted { decrypt_bytes(bytes, lazy_data.keystore.as_ref().ok_or(anyhow!("no keystore"))?)? } else { bytes.to_vec() };
                    let proto = vec_types::VecArcValue::decode(&bytes)?;
                    let mut vec = Vec::new();
                    for entry in proto.entries {
                        let mut av = Self::deserialize(&entry, lazy_data.keystore.as_ref())?;
                        let item = av.as_type::<T>()?;
                        vec.push(item);
                    }
                    *actual_value = ErasedArc::new(Arc::new(vec));
                }
                actual_value.as_arc::<Vec<T>>()
            }
            None => Err(anyhow!("Null value")),
        }
    }

    pub fn as_map_ref<T>(&mut self) -> Result<Arc<HashMap<String, T>>>
    where
        T: 'static + Clone + CustomFromBytes + Debug + Send + Sync,
    {
        // Integrate intrinsic logic, remove registry parts
        if self.category != ValueCategory::Map {
            return Err(anyhow!("Value is not a map (category: {:?})", self.category));
        }
        match &mut self.value {
            Some(ref mut actual_value) => {
                if actual_value.is_lazy {
                    // Extract lazy data
                    let lazy_data = actual_value.get_lazy_data()?;
                    let bytes = &lazy_data.original_buffer[lazy_data.start_offset..lazy_data.end_offset];
                    let is_encrypted = lazy_data.type_name.starts_with("Encrypted");
                    let bytes = if is_encrypted { decrypt_bytes(bytes, lazy_data.keystore.as_ref().ok_or(anyhow!("no keystore"))?)? } else { bytes.to_vec() };
                    let proto = map_types::StringToArcValueMap::decode(&bytes)?;
                    let mut map = HashMap::new();
                    for (k, v_bytes) in proto.entries {
                        let mut av = Self::deserialize(&v_bytes, lazy_data.keystore.as_ref())?;
                        let value = if TypeId::of::<T>() == TypeId::of::<ArcValue>() { av } else { ArcValue { value: Some(ErasedArc::new(Arc::new(av.as_type::<T>()?))), ..av } };
                        map.insert(k, value);
                    }
                    *actual_value = ErasedArc::new(Arc::new(map));
                }
                actual_value.as_arc::<HashMap<String, T>>()
            }
            None => Err(anyhow!("Null value")),
        }
    }

    pub fn as_struct_ref<T>(&mut self) -> Result<Arc<T>>
    where
        T: 'static + Clone + CustomFromBytes + Debug + Send + Sync,
    {
        // Integrate intrinsic logic, remove registry parts
        if self.category != ValueCategory::Struct {
            return Err(anyhow!("Value is not a struct (category: {:?})", self.category));
        }
        match &mut self.value {
            Some(ref mut actual_value) => {
                if actual_value.is_lazy {
                    // Extract lazy data
                    let lazy_data = actual_value.get_lazy_data()?;
                    let bytes = &lazy_data.original_buffer[lazy_data.start_offset..lazy_data.end_offset];
                    let is_encrypted = lazy_data.type_name.starts_with("Encrypted");
                    let bytes = if is_encrypted { decrypt_bytes(bytes, lazy_data.keystore.as_ref().ok_or(anyhow!("no keystore"))?)? } else { bytes.to_vec() };
                    let decoded = T::from_plain_bytes(&bytes, lazy_data.keystore.as_ref())?;
                    *actual_value = ErasedArc::new(Arc::new(decoded));
                }
                actual_value.as_arc::<T>()
            }
            None => Err(anyhow!("Null value")),
        }
    }
}

impl CustomFromBytes for HashMap<String, ArcValue> {
    fn from_plain_bytes(bytes: &[u8], keystore: Option<&Arc<KeyStore>>) -> Result<Self> {
        let proto = map_types::StringToArcValueMap::decode(bytes)?;
        let mut map = HashMap::new();
        for (k, v_bytes) in proto.entries {
            map.insert(k, ArcValue::deserialize(&v_bytes, keystore)?);
        }
        Ok(map)
    }
    fn from_encrypted_bytes(bytes: &[u8], keystore: Option<&Arc<KeyStore>>) -> Result<Self> {
        let ks = keystore.ok_or(anyhow!("Keystore required for decryption"))?;
        let decrypted = decrypt_bytes(bytes, ks)?;
        Self::from_plain_bytes(&decrypted, keystore)
    }
    fn to_binary(&self, keystore: Option<&Arc<KeyStore>>, resolver: Option<&dyn LabelResolver>) -> Result<Vec<u8>> {
        let mut proto = map_types::StringToArcValueMap::default();
        for (k, v) in self.iter() {
            proto.entries.insert(k.clone(), v.serialize(keystore, resolver)?);
        }
        Ok(proto.encode_to_vec())
    }
}

impl CustomFromBytes for Vec<ArcValue> {
    fn from_plain_bytes(bytes: &[u8], keystore: Option<&Arc<KeyStore>>) -> Result<Self> {
        let proto = vec_types::VecArcValue::decode(bytes)?;
        let mut vec = Vec::new();
        for entry in proto.entries {
            vec.push(ArcValue::deserialize(&entry, keystore)?);
        }
        Ok(vec)
    }
    fn from_encrypted_bytes(bytes: &[u8], keystore: Option<&Arc<KeyStore>>) -> Result<Self> {
        let ks = keystore.ok_or(anyhow!("Keystore required for decryption"))?;
        let decrypted = decrypt_bytes(bytes, ks)?;
        Self::from_plain_bytes(&decrypted, keystore)
    }
    fn to_binary(&self, keystore: Option<&Arc<KeyStore>>, resolver: Option<&dyn LabelResolver>) -> Result<Vec<u8>> {
        let mut proto = vec_types::VecArcValue::default();
        for item in self {
            proto.entries.push(item.serialize(keystore, resolver)?);
        }
        Ok(proto.encode_to_vec())
    }
}

fn convert_to_t<T: 'static + Clone>(value: impl Any) -> Result<T> {
    let boxed = Box::new(value) as Box<dyn Any>;
    boxed.downcast::<T>().map(|b| (*b).clone()).map_err(|_| anyhow!("Type mismatch"))
}
