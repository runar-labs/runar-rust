import { describe, it, expect, beforeAll, afterAll } from 'vitest';

// Import the compiled native module - this will be generated by napi
// The exact import path depends on napi build output
let runarTs: any;

beforeAll(async () => {
  try {
    // Try to import the built native module
    runarTs = await import('../index.js');
  } catch (error) {
    console.warn('Native module not built yet. Run: npm run build:debug');
    throw error;
  }
});

describe('Runar TypeScript FFI', () => {
  let node: any;

  beforeAll(async () => {
    // Create a new node instance
    node = new runarTs.JsNode();
  });

  afterAll(async () => {
    if (node) {
      try {
        await node.stop();
      } catch (error) {
        // Ignore stop errors in tests
        console.warn('Error stopping node:', error);
      }
    }
  });

  it('should create a node instance', () => {
    expect(node).toBeDefined();
    expect(typeof node.start).toBe('function');
    expect(typeof node.stop).toBe('function');
    expect(typeof node.request).toBe('function');
    expect(typeof node.publish).toBe('function');
    expect(typeof node.addService).toBe('function');
  });

  it('should start and stop the node', async () => {
    await expect(node.start()).resolves.toBeUndefined();
    await expect(node.stop()).resolves.toBeUndefined();
  });

  it('should add a JavaScript service', async () => {
    const jsService = {
      name: 'test-service',
      path: 'test',
      version: '1.0.0',
      description: 'Test service for FFI validation'
    };

    await expect(node.addService(jsService)).resolves.toBeUndefined();
  });

  it('should handle service requests after adding service', async () => {
    // Start the node first
    await node.start();

    // Add our test service
    const jsService = {
      name: 'math-service',
      path: 'math',
      version: '1.0.0',
      description: 'Math operations service'
    };

    await node.addService(jsService);

    // Test the echo action (which our wrapper automatically registers)
    const response = await node.request('math/echo', { message: 'hello world' });
    expect(response).toBeDefined();
    
    // The response should echo back our input or return the default message
    console.log('Service response:', response);

    // Stop the node after test
    await node.stop();
  });

  it('should publish events', async () => {
    await node.start();
    
    // Publishing should not throw errors
    await expect(node.publish('test/event', { data: 'test payload' })).resolves.toBeUndefined();
    
    await node.stop();
  });

  it('should handle requests to non-existent services gracefully', async () => {
    await node.start();
    
    // This should throw an error since the service doesn't exist
    await expect(node.request('nonexistent/action', {})).rejects.toThrow();
    
    await node.stop();
  });

  it('should handle null payloads', async () => {
    await node.start();
    
    const jsService = {
      name: 'null-test-service',
      path: 'nulltest',
    };

    await node.addService(jsService);

    // Test with null payload
    const response = await node.request('nulltest/echo', null);
    expect(response).toBeDefined();
    
    await node.stop();
  });

  it('should handle math service with add action', async () => {
    await node.start();
    
    const mathService = {
      name: 'math-service',
      path: 'math',
      version: '1.0.0',
      description: 'Math operations service',
      actions: {
        add: true, // Enable the add action
        echo: false // Disable echo for this service
      }
    };

    await node.addService(mathService);

    // Test the add action
    const response = await node.request('math/add', { a: 5, b: 3 });
    expect(response).toBe(8); // Should return the sum
    
    // Test with invalid payload
    await expect(node.request('math/add', { a: 5 })).rejects.toThrow();
    
    await node.stop();
  });
}); 