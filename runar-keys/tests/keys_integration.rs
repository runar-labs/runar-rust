use runar_keys::*;

#[test]
fn test_key_generation_and_derivation() {

    // NOTE DO NOT CHANGE THE COMMENTS/INSTRUCTIONS HERE, UNLESS THERE IS AN ISSUE WITH IT AND IS CONFIRMED WITH THE USER
    // This goal of this test is to simulate the end to end flows.
    // in the real implemetnation the mobile process  and the node
    // process will be in different machines and talkig over the network,
    // but here we want to simulate the end to ened and  test the whole flow.
    // so  we willl bypass the network part and deal with the internal compionents
    // that will do the encryption part whic is what we need to develop and test here.
    // both mobile and node use the same codebase.  just doing acting in different roles.
    // make sure we keep instances od the same object separate in memory (one for mobiule and node)
    // to simulate the separation and avoid an implementation that tried to access data that it should not be able to.

    // DESIGN NOTES. we need to implement the primitives of encryptes.. the keyes, derivation,
    // shared secrets, envelop, sign, encryption/decrtption.. lets use crypto box for it https://github.com/RustCrypto/nacl-compat
    // We also need a higher level object (manager) that store the keys in mermory and proovidue the API for this dataflow.
    // keys wil be either generated by these objects (when in mobile or in node) or keys will be provided
    // (whe they arelady exists - will be lo9ade dfrom a secure storatge and loaded in this object (manager))
    // So for this test we dont need to worry about storage. this will be the next step.

    // 1 - (mobile side) - generate user master key
    let mut mobile = MobileKeyManager::new();
    mobile.generate_seed();
    let user_root_key = mobile.generate_user_root_key().expect("Failed to generate user root key");
    assert!(user_root_key.public_key_bytes().len() > 0, "User root key should have a valid public key");
    
    // Create a network for our test
    let network_id = "test_network";
    let ca_key = mobile.generate_network_ca_key(network_id).expect("Failed to generate network CA key");
    assert!(ca_key.public_key_bytes().len() > 0, "Network CA key should have a valid public key");
    
    // 2 - node side (setup mode) - generates its generate its own TLS and Storage keypairs
    //     and geneated a setup handshake token which contains the CSR request and the node public key
    //     which will be presented as QR code.. here in the test we use the token as a string dfirectly.
    let node_id = "test_node";
    let mut node = NodeKeyManager::new(node_id);
    let setup_token = node.generate_setup_token().expect("Failed to generate setup token");
    assert_eq!(setup_token.node_id, node_id, "Setup token should contain the correct node ID");
    
    // 3 - (mobile side) - received the token and sign the CSR
    let signed_cert = mobile.process_setup_token(&setup_token, network_id).expect("Failed to process setup token");
    assert_eq!(signed_cert.issuer, format!("ca:{}", network_id), "Certificate should be issued by the network CA");
    
    // 4 - (node side) - received the signed CSR and generate the node membership certificate, stored encrypted and secure.
    node.process_signed_certificate(signed_cert).expect("Failed to process signed certificate");
    
    // FROM THIS POINT THE NODE AND MOBILE WILL CONNECT USING THE NEW CERTIFICATES AND FURTHER COMMS ARE SECURED AND ECNRYPTED USING THESE NEW CREDENTIALS.
    
    // 5 - (mobile side) -  generate A NETWORK KEY AND SHARE IT WITH THE NODE
    let network_key = mobile.generate_network_data_key(network_id).expect("Failed to generate network data key");
    
    // In a real implementation, the network key would be encrypted and sent over the network
    // For this test, we'll directly share it with the node
    let network_key_clone = EncryptionKeyPair::from_secret(&network_key.secret_key_bytes()).expect("Failed to clone network key");
    
    // 6 - (node side) - received the network key and store it encrypted and secure.
    node.store_network_key(network_id, network_key_clone).expect("Failed to store network key");
    node.set_network_id(network_id);
    
    // 7 - (mobile side) - GENERATE A USER profile key.
    let (profile_key, profile_index) = mobile.generate_user_profile_key().expect("Failed to generate user profile key");
    assert!(profile_key.public_key_bytes().len() > 0, "User profile key should have a valid public key");
    
    // 8 - (mobile side) - Encrypts data using envelop which is encrypted using the
    //     user profile key and network key.
    //     so only the user or apps running in the network can decrypt it.
    let test_data = b"This is a test message that should be encrypted and decrypted";
    let envelope = mobile.encrypt_for_network_and_profile(test_data, network_id, profile_index)
        .expect("Failed to encrypt data");
    
    // 9 - (node side) - received the encrypted data and decrypts it using the
    //     network key. (the node does not have the user profile key - so it needs a shared secreted)
    let decrypted_by_node = node.decrypt_with_network_key(&envelope).expect("Node failed to decrypt data");
    assert_eq!(decrypted_by_node, test_data, "Node should be able to decrypt the data");
    
    // Additionally, verify that the mobile can also decrypt the data using the profile key
    let decrypted_by_mobile = mobile.decrypt_with_profile_key(&envelope, profile_index)
        .expect("Mobile failed to decrypt data");
    assert_eq!(decrypted_by_mobile, test_data, "Mobile should be able to decrypt the data");
}
