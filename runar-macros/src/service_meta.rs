use proc_macro::TokenStream;
use quote::quote;
use std::collections::HashMap;
use syn::{parse_macro_input, ItemStruct};

/// Internal helper â€“ parse `name = ".."` style attribute list into a HashMap
fn parse_attrs(attr: TokenStream) -> HashMap<String, String> {
    let mut map = HashMap::new();

    if attr.is_empty() {
        return map;
    }

    let attr_str = attr.to_string();
    for pair in attr_str.split(',') {
        let parts: Vec<&str> = pair.split('=').collect();
        if parts.len() != 2 {
            continue;
        }
        let key = parts[0].trim().to_string();
        let value_part = parts[1].trim();
        if value_part.starts_with('"') && value_part.ends_with('"') {
            let value = value_part[1..value_part.len() - 1].to_string();
            map.insert(key, value);
        }
    }
    map
}

// Internal implementation called from lib.rs entry point.
pub fn service_meta_impl(attr: TokenStream, item: TokenStream) -> TokenStream {
    // Keep original struct tokens for later re-emission.
    let input_clone = proc_macro2::TokenStream::from(item.clone());
    let input_ast = parse_macro_input!(item as ItemStruct);
    let struct_ident = &input_ast.ident;

    // Parse the attribute list.
    let attr_map = parse_attrs(attr);

    let name_value = attr_map
        .get("name")
        .cloned()
        .unwrap_or_else(|| struct_ident.to_string());
    let path_value = attr_map
        .get("path")
        .cloned()
        .unwrap_or_else(|| name_value.to_lowercase().replace(' ', "_"));
    let description_value = attr_map
        .get("description")
        .cloned()
        .unwrap_or_else(|| format!("Service generated by service_meta for {struct_ident}"));
    let version_value = attr_map
        .get("version")
        .cloned()
        .unwrap_or_else(|| "1.0.0".to_string());

    // Generate inherent helper methods returning &'static str.
    let expanded = quote! {
        #input_clone

        // Auto-generated metadata helpers (inherent impl)
        impl #struct_ident {
            #[allow(dead_code)]
            #[inline]
            pub fn __runar_meta_name(&self) -> &str { #name_value }
            #[allow(dead_code)]
            #[inline]
            pub fn __runar_meta_path(&self) -> &str { #path_value }
            #[allow(dead_code)]
            #[inline]
            pub fn __runar_meta_description(&self) -> &str { #description_value }
            #[allow(dead_code)]
            #[inline]
            pub fn __runar_meta_version(&self) -> &str { #version_value }
        }
    };

    TokenStream::from(expanded)
}
