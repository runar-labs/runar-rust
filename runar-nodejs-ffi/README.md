# Runar Node.js FFI

This crate exposes the native Rust **Runar** node to JavaScript/TypeScript
through **napi-rs**. It adds an ergonomic TS runtime so applications can write
and test services completely in JS/TS while still delegating networking,
cryptography and persistence to the Rust core.

> **High-level picture**
>
> ┌──────────────┐      napi-rs TSFN       ┌──────────────┐
> │  JavaScript  │  ───────────────────▶  │    Rust      │
> │  (ts/runtime)│                         │ (src/lib.rs) │
> └──────────────┘  ◀───────────────────  └──────────────┘
>         ▲  ▲                                       │
>         │  └──── fast-path direct calls            │
>         │        (no Rust hop)                     ▼
>         │                                   Runar core  

---

## 1  Folder layout

```
runar-nodejs-ffi/
├─ src/              # native Rust addon (napi-rs entry points)
│   └─ lib.rs        # exposes JsNode + dispatcher TSFN
├─ ts/               # hand-written TypeScript façade
│   ├─ dispatcher.ts # one-time JS ↔︎ Rust message fan-out
│   └─ runtime.ts    # RunarNode wrapper / service registry
├─ test/             # Vitest suites exercising both layers
├─ index.js          # autogenerated napi-rs loader – **do not edit**
├─ index.d.ts        # public typings re-exporting RunarNode etc.
├─ tsconfig.json     # TS build config (includes `ts/` and `test/`)
├─ Cargo.toml        # Rust crate manifest
└─ package.json      # npm metadata / scripts (build, test)
```


## 2  Public JavaScript API

```ts
import { RunarNode } from "./ts/runtime";

const node = new RunarNode();
await node.addService({
  name: "Math Service",          // metadata only
  path: "math_service",          // routing prefix (MUST match in requests)
  version: "1.0.0",
  description: "Basic arithmetic",
  actions: {
    add: ({ a, b }, ctx) => a + b + 1,        // ctx.request / publish / logger
    multiply: ({ a, b }) => a * b,
  },
});

const answer = await node.request("math_service/add", { a: 2, b: 3 });
```

### 2.1  Context helpers
* `ctx.request(path, payload)` – async REQ/RES to any action (local or remote)
* `ctx.publish(topic, data)`   – fire-and-forget event
* `ctx.logger`                – pipes to console (replaceable)

### 2.2  ServiceDefinition contract
| field     | purpose | notes |
|-----------|---------|-------|
| `name`    | human readable | not used for routing |
| `path`    | **unique** routing prefix | NO whitespace |
| `version` | semantic version string | validated in Rust |
| `actions` | object of `async (payload, ctx)` | names become `<path>/<key>` |


## 3  Internal mechanics

1. **Rust side** (`src/lib.rs`)
   * Implements `JsNode` (create/start/stop/request/publish/addService).
   * Exposes **thread-safe function** (`registerJsDispatch`) to push
     incoming network messages into JS.
   * Validates that `ServiceDefinition.path` is non-empty and has zero
     whitespace – this prevents the earlier *name vs path* bug.

2. **Dispatcher (ts/dispatcher.ts)**
   * Calls `registerJsDispatch` **exactly once per process** and then
     multicasts every message to registered callbacks.
   * API: `attachDispatcher(cb)` / `detachDispatcher(cb)`.

3. **Runtime (ts/runtime.ts)**
   * On first use, starts the native node and attaches one dispatcher
     callback.
   * Maintains an **in-memory service registry** (keyed by `path`).
   * Fast-path optimisation: if `request()` targets a *local* service it
     calls the JS action directly – no Rust/JSON round-trip.

4. **index.js**
   * Generated by napi-rs. Picks the right `*.node` binary for the
     platform.  Keep it JS so upstream tooling stays compatible.


## 4  Building & testing

```bash
# compile Rust addon (release)
npm run build   # alias for `cargo build --release && tsc`

# run Vitest suites (TS + native addon)
npm test
```

*The test matrix intentionally starts **two** independent Rust nodes to
prove multi-instance safety.*


## 5  Contributor guidelines / Do-not-break list

1. **Never call `registerJsDispatch` directly** – use
   `attachDispatcher` so we keep a single TSFN.
2. Keep the `ServiceDefinition` **`path` ≠ `name`** invariant.
3. If you rename or move `ts/` sources, update `tsconfig.json` *and* the
   `package.json#types` field.
4. When adding new native methods, surface them through `index.d.ts` and
   a wrapper in `ts/` – avoids direct JS dependency on generated loader.
5. New tests **must** clean up dispatcher callbacks via `detachDispatcher`
   to avoid cross-suite leakage.
6. Do not edit `index.js`; regenerate by `cargo build -p runar-nodejs-ffi`.
7. Run `npm test` before every commit; CI expects all suites to pass.


## 6  Future work ideas
* **Typed payload schema** handshake between Rust ↔︎ JS (zod/json-schema).
* Hot-reloading services during development.
* ESM-only build (drop CJS loader) once napi-rs releases stable support.

---
Happy hacking – and keep the dispatcher single! 🎉 