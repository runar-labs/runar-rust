# Runar Node.js FFI

This crate exposes the native Rust **Runar** node to JavaScript/TypeScript
through **napi-rs**. It adds an ergonomic TS runtime so applications can write
and test services completely in JS/TS while still delegating networking,
cryptography and persistence to the Rust core.

> **High-level picture**
>
> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      napi-rs TSFN       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
> â”‚  JavaScript  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  â”‚    Rust      â”‚
> â”‚  (ts/runtime)â”‚                         â”‚ (src/lib.rs) â”‚
> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
>         â–²  â–²                                       â”‚
>         â”‚  â””â”€â”€â”€â”€ fast-path direct calls            â”‚
>         â”‚        (no Rust hop)                     â–¼
>         â”‚                                   Runar core  

---

## 1  Folder layout

```
runar-nodejs-ffi/
â”œâ”€ src/              # native Rust addon (napi-rs entry points)
â”‚   â””â”€ lib.rs        # exposes JsNode + dispatcher TSFN
â”œâ”€ ts/               # hand-written TypeScript faÃ§ade
â”‚   â”œâ”€ dispatcher.ts # one-time JS â†”ï¸Ž Rust message fan-out
â”‚   â””â”€ runtime.ts    # RunarNode wrapper / service registry
â”œâ”€ test/             # Vitest suites exercising both layers
â”œâ”€ index.js          # autogenerated napi-rs loader â€“ **do not edit**
â”œâ”€ index.d.ts        # public typings re-exporting RunarNode etc.
â”œâ”€ tsconfig.json     # TS build config (includes `ts/` and `test/`)
â”œâ”€ Cargo.toml        # Rust crate manifest
â””â”€ package.json      # npm metadata / scripts (build, test)
```


## 2  Public JavaScript API

```ts
import { RunarNode } from "./ts/runtime";

const node = new RunarNode();
await node.addService({
  name: "Math Service",          // metadata only
  path: "math_service",          // routing prefix (MUST match in requests)
  version: "1.0.0",
  description: "Basic arithmetic",
  actions: {
    add: ({ a, b }, ctx) => a + b + 1,        // ctx.request / publish / logger
    multiply: ({ a, b }) => a * b,
  },
});

const answer = await node.request("math_service/add", { a: 2, b: 3 });
```

### 2.1  Context helpers
* `ctx.request(path, payload)` â€“ async REQ/RES to any action (local or remote)
* `ctx.publish(topic, data)`   â€“ fire-and-forget event
* `ctx.logger`                â€“ pipes to console (replaceable)

### 2.2  ServiceDefinition contract
| field     | purpose | notes |
|-----------|---------|-------|
| `name`    | human readable | not used for routing |
| `path`    | **unique** routing prefix | NO whitespace |
| `version` | semantic version string | validated in Rust |
| `actions` | object of `async (payload, ctx)` | names become `<path>/<key>` |


## 3  Internal mechanics

1. **Rust side** (`src/lib.rs`)
   * Implements `JsNode` (create/start/stop/request/publish/addService).
   * Exposes **thread-safe function** (`registerJsDispatch`) to push
     incoming network messages into JS.
   * Validates that `ServiceDefinition.path` is non-empty and has zero
     whitespace â€“ this prevents the earlier *name vs path* bug.

2. **Dispatcher (ts/dispatcher.ts)**
   * Calls `registerJsDispatch` **exactly once per process** and then
     multicasts every message to registered callbacks.
   * API: `attachDispatcher(cb)` / `detachDispatcher(cb)`.

3. **Runtime (ts/runtime.ts)**
   * On first use, starts the native node and attaches one dispatcher
     callback.
   * Maintains an **in-memory service registry** (keyed by `path`).
   * Fast-path optimisation: if `request()` targets a *local* service it
     calls the JS action directly â€“ no Rust/JSON round-trip.

4. **index.js**
   * Generated by napi-rs. Picks the right `*.node` binary for the
     platform.  Keep it JS so upstream tooling stays compatible.


## 4  Building & testing

```bash
# compile Rust addon (release)
npm run build   # alias for `cargo build --release && tsc`

# run Vitest suites (TS + native addon)
npm test
```

*The test matrix intentionally starts **two** independent Rust nodes to
prove multi-instance safety.*


## 5  Contributor guidelines / Do-not-break list

1. **Never call `registerJsDispatch` directly** â€“ use
   `attachDispatcher` so we keep a single TSFN.
2. Keep the `ServiceDefinition` **`path` â‰  `name`** invariant.
3. If you rename or move `ts/` sources, update `tsconfig.json` *and* the
   `package.json#types` field.
4. When adding new native methods, surface them through `index.d.ts` and
   a wrapper in `ts/` â€“ avoids direct JS dependency on generated loader.
5. New tests **must** clean up dispatcher callbacks via `detachDispatcher`
   to avoid cross-suite leakage.
6. Do not edit `index.js`; regenerate by `cargo build -p runar-nodejs-ffi`.
7. Run `npm test` before every commit; CI expects all suites to pass.


## 6  Future work ideas
* **Typed payload schema** handshake between Rust â†”ï¸Ž JS (zod/json-schema).
* Hot-reloading services during development.
* ESM-only build (drop CJS loader) once napi-rs releases stable support.

---
Happy hacking â€“ and keep the dispatcher single! ðŸŽ‰ 